// Package docgen generates documentation from registered rules.
package docgen

import (
	"fmt"
	"io"
	"sort"
	"strings"

	"github.com/lex00/cfn-lint-go/pkg/rules"
)

// categoryInfo maps rule prefixes to category names
var categoryInfo = map[string]string{
	"E0xxx": "Template Errors",
	"E1xxx": "Functions",
	"E2xxx": "Parameters",
	"E3xxx": "Resources",
	"E4xxx": "Metadata",
	"E5xxx": "Modules",
	"E6xxx": "Outputs",
	"E7xxx": "Mappings",
	"E8xxx": "Conditions",
	"W1xxx": "Template Warnings",
	"W2xxx": "Parameter Warnings",
	"W3xxx": "Resource Warnings",
	"W4xxx": "Metadata Warnings",
	"W6xxx": "Output Warnings",
	"W7xxx": "Mapping Warnings",
	"W8xxx": "Condition Warnings",
	"I1xxx": "Template Informational",
	"I2xxx": "Parameter Informational",
	"I3xxx": "Resource Informational",
	"I6xxx": "Output Informational",
	"I7xxx": "Mapping Informational",
}

// GetRulePrefix returns the category prefix for a rule ID (e.g., "E1001" -> "E1xxx")
func GetRulePrefix(ruleID string) string {
	if len(ruleID) < 2 {
		return ""
	}
	return ruleID[:2] + "xxx"
}

// GetRuleCategory returns the category name for a rule ID
func GetRuleCategory(ruleID string) string {
	prefix := GetRulePrefix(ruleID)
	if cat, ok := categoryInfo[prefix]; ok {
		return cat
	}
	return "Unknown"
}

// GenerateRulesMarkdown generates a RULES.md file from the provided rules
func GenerateRulesMarkdown(w io.Writer, ruleList []rules.Rule) error {
	// Write header
	fmt.Fprintln(w, "# Rules Reference")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "<!-- This file is auto-generated by cfn-lint --update-documentation. Do not edit manually. -->")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "cfn-lint-go implements rules from [aws-cloudformation/cfn-lint](https://github.com/aws-cloudformation/cfn-lint).")
	fmt.Fprintln(w)

	if len(ruleList) == 0 {
		fmt.Fprintln(w, "No rules are currently registered.")
		return nil
	}

	// Group rules by category
	categories := make(map[string][]rules.Rule)
	for _, r := range ruleList {
		prefix := GetRulePrefix(r.ID())
		categories[prefix] = append(categories[prefix], r)
	}

	// Sort rules within each category
	for prefix := range categories {
		sort.Slice(categories[prefix], func(i, j int) bool {
			return categories[prefix][i].ID() < categories[prefix][j].ID()
		})
	}

	// Define category order
	categoryOrder := []string{
		"E0xxx", "E1xxx", "E2xxx", "E3xxx", "E4xxx", "E5xxx", "E6xxx", "E7xxx", "E8xxx",
		"W1xxx", "W2xxx", "W3xxx", "W4xxx", "W6xxx", "W7xxx", "W8xxx",
		"I1xxx", "I2xxx", "I3xxx", "I6xxx", "I7xxx",
	}

	// Count rules and generate summary
	fmt.Fprintf(w, "## Current Status\n\n")
	fmt.Fprintf(w, "**%d rules implemented**\n\n", len(ruleList))

	// Generate category summary table
	fmt.Fprintln(w, "## Rule Categories")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "| Prefix | Category | Count |")
	fmt.Fprintln(w, "|--------|----------|-------|")

	totalCount := 0
	for _, prefix := range categoryOrder {
		if rules, ok := categories[prefix]; ok && len(rules) > 0 {
			cat := categoryInfo[prefix]
			fmt.Fprintf(w, "| %s | %s | %d |\n", prefix, cat, len(rules))
			totalCount += len(rules)
		}
	}
	fmt.Fprintf(w, "| **Total** | | **%d** |\n", totalCount)
	fmt.Fprintln(w)

	// Generate detailed sections for each category
	fmt.Fprintln(w, "## Implemented Rules")
	fmt.Fprintln(w)

	for _, prefix := range categoryOrder {
		rulesList, ok := categories[prefix]
		if !ok || len(rulesList) == 0 {
			continue
		}

		cat := categoryInfo[prefix]
		fmt.Fprintf(w, "### %s - %s\n\n", prefix, cat)
		fmt.Fprintln(w, "| Rule | Description | Status |")
		fmt.Fprintln(w, "|------|-------------|--------|")

		for _, r := range rulesList {
			// Escape pipe characters in description
			desc := strings.ReplaceAll(r.ShortDesc(), "|", "\\|")
			fmt.Fprintf(w, "| %s | %s | Implemented |\n", r.ID(), desc)
		}
		fmt.Fprintln(w)
	}

	// Add ignoring rules section
	fmt.Fprintln(w, "## Rule Severity Levels")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "- **E (Error)**: Must be fixed for valid CloudFormation")
	fmt.Fprintln(w, "- **W (Warning)**: Best practice violations")
	fmt.Fprintln(w, "- **I (Informational)**: Suggestions and tips")
	fmt.Fprintln(w)

	fmt.Fprintln(w, "## Ignoring Rules")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "### CLI")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "```bash")
	fmt.Fprintln(w, "cfn-lint template.yaml --ignore-rules E1001,W3002")
	fmt.Fprintln(w, "```")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "### Configuration File")
	fmt.Fprintln(w)
	fmt.Fprintln(w, "```yaml")
	fmt.Fprintln(w, "ignore_checks:")
	fmt.Fprintln(w, "  - E1001")
	fmt.Fprintln(w, "  - W3002")
	fmt.Fprintln(w, "```")
	fmt.Fprintln(w)

	return nil
}
